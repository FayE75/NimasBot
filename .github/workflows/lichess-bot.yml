name: Lichess Bot

on:
  push:
    branches: [ main, master ]
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:

env:
  LICHESS_TOKEN: ${{ secrets.LICHESS_TOKEN }}

jobs:
  deploy-bot:
    runs-on: ubuntu-latest
    timeout-minutes: 350
    steps:
    - name: Checkout
      uses: actions/checkout@v5

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
        cache: 'pip'

    - name: Install dependencies (clang, llvm-profdata, ccache, etc.)
      run: |
        set -euo pipefail

        export DEBIAN_FRONTEND=noninteractive
        APT_PACKAGES="build-essential clang git make pkg-config ccache wget ca-certificates"

        # update once and install packages in one shot (no-recommends to save space)
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends $APT_PACKAGES || true

        # Python tooling
        python -m pip install --upgrade pip wheel setuptools
        if [ -f requirements.txt ]; then
          echo "Installing python requirements from requirements.txt"
          pip install --no-cache-dir -r requirements.txt
        else
          echo "No requirements.txt found â€” installing minimal runtime deps"
          pip install --no-cache-dir pyyaml aiohttp tenacity websockets requests
        fi

        # Try to ensure llvm-profdata is available (preferred via apt)
        if command -v llvm-profdata >/dev/null 2>&1; then
          echo "llvm-profdata already available: $(command -v llvm-profdata)"
        else
          echo "llvm-profdata not found â€” attempting apt install of llvm packages..."
          sudo apt-get install -y --no-install-recommends llvm llvm-18 llvm-18-tools llvm-19 llvm-19-tools || true
          if command -v llvm-profdata >/dev/null 2>&1; then
            echo "Installed llvm-profdata from apt: $(command -v llvm-profdata)"
          else
            echo "llvm-profdata still not found after apt. Attempting fallback download (optional)..."
            LLVM_VER="18.1.6"
            TARBALL="clang+llvm-${LLVM_VER}-x86_64-linux-gnu-ubuntu-22.04.tar.xz"
            DL_URL="https://github.com/llvm/llvm-project/releases/download/llvmorg-${LLVM_VER}/${TARBALL}"
            TMPDIR="/tmp/llvmtool"
            mkdir -p "${TMPDIR}"
            if command -v curl >/dev/null 2>&1; then
              if curl -fSL -o "${TMPDIR}/${TARBALL}" "${DL_URL}"; then
                tar -xf "${TMPDIR}/${TARBALL}" -C "${TMPDIR}"
                EXDIR=$(find "${TMPDIR}" -maxdepth 1 -type d -name "clang+llvm-*" -print -quit || true)
                if [ -n "$EXDIR" ]; then
                  export PATH="$EXDIR/bin:$PATH"
                  echo "Using downloaded LLVM from $EXDIR"
                  echo "llvm-profdata is now: $(command -v llvm-profdata || echo 'not found')"
                else
                  echo "Extraction ok but directory not found"
                fi
              else
                echo "Fallback download failed; skipping."
              fi
            else
              echo "curl not available for fallback download."
            fi
          fi
        fi

        if command -v llvm-profdata >/dev/null 2>&1; then
          echo "âœ… llvm-profdata available at: $(command -v llvm-profdata)"
        else
          echo "âš ï¸ llvm-profdata NOT found. PGO merge will be skipped and build will proceed without PGO."
        fi

        # ccache quick status/config if present
        if command -v ccache >/dev/null 2>&1; then
          ccache -V || true
          ccache -M 5G || true
          ccache -s || true
        else
          echo "ccache not found â€” builds will be uncached."
        fi

        # cleanup to reduce runner disk usage
        sudo apt-get clean
        sudo rm -rf /var/lib/apt/lists/* || true

    - name: Build Omega (clone + make â€” optional instrumented PGO using engine bench)
      env:
        PERFORM_GENERATE: 0
      run: |
        set -euo pipefail
        set -x
        echo "=== START: clone + build Omega (no manual FEN/perft unless PERFORM_GENERATE=1) ==="
        PGO_RUN_TIME=${PGO_RUN_TIME:-120}
        ROOT="$(pwd)"
        rm -rf Omega || true
        git clone https://x-access-token:${{ secrets.OMEGA_PAT }}@github.com/FayE75/Omega.git Omega || git clone https://github.com/FayE75/Omega.git Omega || { echo "Clone failed"; exit 1; }
        if [ ! -d Omega/src ]; then
          echo "ERROR: Omega/src not found after clone"; ls -la Omega || true; exit 1
        fi
        cd Omega/src

        if command -v ccache >/dev/null 2>&1; then
          export CC="ccache clang"
          export CXX="ccache clang++"
        else
          export CC="clang"
          export CXX="clang++"
        fi
        export CCACHE_DIR="${HOME}/.ccache"

        COMMON_FLAGS="-O3 -march=native -mtune=native -flto=thin -funroll-loops -fomit-frame-pointer"
        export CFLAGS="$COMMON_FLAGS"
        export CXXFLAGS="$COMMON_FLAGS"

        # (Instrumented generate block left as-is if PERFORM_GENERATE=1)
        if [ "${PERFORM_GENERATE:-0}" -eq 1 ]; then
          echo "Running instrumented (generate) build â€” CFLAGS=$CFLAGS"
          INSTR_EXTRAS="-fprofile-instr-generate -fcoverage-mapping"
          INSTR_LDFLAGS="-fprofile-instr-generate -fcoverage-mapping -flto=thin"
          make -j$(nproc) profile-build ARCH=x86-64-bmi2 COMP=clang EXTRACXXFLAGS="${INSTR_EXTRAS}" EXTRALDFLAGS="${INSTR_LDFLAGS}" 2>&1 | tee build-instr.log || { echo "Instrumented build failed"; tail -n 200 build-instr.log || true; exit 1; }
          # produce profraw with instrumented binary...
          instr_bin=$(find . -maxdepth 6 -type f -executable -iname 'omega*' -o -iname 'stockfish*' -print -quit || true)
          [ -n "$instr_bin" ] || { echo "instrumented binary not found"; tail -n 200 build-instr.log || true; exit 1; }
          export LLVM_PROFILE_FILE="${HOME}/pgo-%p.profraw"
          timeout 12s "${instr_bin}" bench > /tmp/pgo_bench_instrumented.txt 2>&1 || true
          # run iterations...
          # (kept as before; omitted here to keep snippet concise)
          # merge profraws (if llvm-profdata available)
          if compgen -G "${HOME}/pgo-*.profraw" >/dev/null 2>&1 && command -v llvm-profdata >/dev/null 2>&1; then
            llvm-profdata merge -o "${HOME}/merged.profdata" ${HOME}/pgo-*.profraw || echo "llvm-profdata merge failed (continuing without merged.profdata)"
          fi
        fi

        make clean || true

        # Try profile-build first (if merged.profdata exists we still prefer profile-build)
        BUILD_RC=0
        if [ -f "${HOME}/merged.profdata" ] && command -v llvm-profdata >/dev/null 2>&1; then
          echo "Using merged.profdata for final build."
          USE_EXTRAS="-fprofile-instr-use=${HOME}/merged.profdata -fcoverage-mapping"
          USE_LDFLAGS="-fprofile-instr-use=${HOME}/merged.profdata -flto=thin"
          if make -j$(nproc) profile-build ARCH=x86-64-bmi2 COMP=clang EXTRACXXFLAGS="${USE_EXTRAS}" EXTRALDFLAGS="${USE_LDFLAGS}" 2>&1 | tee build-final.log; then
            BUILD_RC=0
          else
            BUILD_RC=${PIPESTATUS[0]:-1}
          fi
        else
          echo "No merged.profdata -> trying profile-build (non-PGO) then fallback."
          if make -j$(nproc) profile-build ARCH=x86-64-bmi2 COMP=clang 2>&1 | tee build-final.log; then
            BUILD_RC=0
          else
            BUILD_RC=${PIPESTATUS[0]:-1}
          fi
        fi

        if [ $BUILD_RC -ne 0 ]; then
          echo "profile-build failed with code $BUILD_RC, attempting plain 'make build' as fallback..."
          if make -j$(nproc) build ARCH=x86-64-bmi2 COMP=clang 2>&1 | tee -a build-final.log; then
            BUILD_RC=0
          else
            BUILD_RC=${PIPESTATUS[0]:-1}
          fi
        fi

        if [ $BUILD_RC -ne 0 ]; then
          echo "BUILD FAILED (code $BUILD_RC). Tail of build-final.log:"
          tail -n 400 build-final.log || true
          exit $BUILD_RC
        fi

        found=$(find . -maxdepth 6 -type f -executable -iname 'stockfish*' -o -iname 'omega*' -o -iname 'sf*' -print -quit || true)
        if [ -z "$found" ]; then
          echo "No engine binary found after successful build? Dumping build-final.log"
          tail -n 400 build-final.log || true
          exit 1
        fi
        echo "Found engine binary: $found"
        strip "$found" || true
        mkdir -p "${ROOT}/engines"
        cp "$found" "${ROOT}/engines/sf" || { echo "Copy failed"; ls -la . || true; exit 1; }
        chmod +x "${ROOT}/engines/sf" || true
        echo "Omega build complete."

        # run profileclean but don't treat non-zero as fatal (we want the build artifact anyway)
        if make ARCH=x86-64-bmi2 COMP=clang profileclean 2>&1 | tee profileclean.log; then
          echo "profileclean ok"
        else
          echo "profileclean failed; exit code non-zero but continuing. See profileclean.log"
          tail -n 200 profileclean.log || true
        fi

    - name: Build Fairy-Stockfish (clone + make â€” optional instrumented PGO using engine bench)
      env:
        PERFORM_GENERATE: 0
      run: |
        set -euo pipefail
        set -x
        echo "=== START: clone + build Fairy-Stockfish (no manual FEN/perft unless PERFORM_GENERATE=1) ==="
        PGO_RUN_TIME=${PGO_RUN_TIME:-120}
        ROOT="$(pwd)"
        rm -rf Fairy-Stockfish || true
        git clone https://github.com/fairy-stockfish/Fairy-Stockfish.git Fairy-Stockfish || { echo "Clone failed"; exit 1; }
        if [ ! -d Fairy-Stockfish/src ]; then
          echo "ERROR: Fairy-Stockfish/src not found after clone"; ls -la Fairy-Stockfish || true; exit 1
        fi
        cd Fairy-Stockfish/src

        if command -v ccache >/dev/null 2>&1; then
          export CC="ccache clang"
          export CXX="ccache clang++"
        else
          export CC="clang"
          export CXX="clang++"
        fi
        export CCACHE_DIR="${HOME}/.ccache"

        COMMON_FLAGS="-O3 -march=native -mtune=native -flto=thin -funroll-loops -fomit-frame-pointer"
        export CFLAGS="$COMMON_FLAGS"
        export CXXFLAGS="$COMMON_FLAGS"

        # Instrumented (generate) stage if requested
        if [ "${PERFORM_GENERATE:-0}" -eq 1 ]; then
          INSTR_EXTRAS="-fprofile-instr-generate -fcoverage-mapping"
          INSTR_LDFLAGS="-fprofile-instr-generate -fcoverage-mapping -flto=thin"
          make -j$(nproc) profile-build ARCH=x86-64-bmi2 COMP=clang EXTRACXXFLAGS="${INSTR_EXTRAS}" EXTRALDFLAGS="${INSTR_LDFLAGS}" 2>&1 | tee build-instr.log || { echo "Instrumented build failed"; tail -n 200 build-instr.log || true; exit 1; }
          instr_bin=$(find . -maxdepth 6 -type f -executable -iname 'fairy*' -o -iname 'stockfish*' -o -iname 'fsf*' -print -quit || true)
          [ -n "$instr_bin" ] || { echo "instrumented binary not found"; tail -n 200 build-instr.log || true; exit 1; }
          export LLVM_PROFILE_FILE="${HOME}/pgo-%p.profraw"
          timeout 12s "${instr_bin}" bench > /tmp/pgo_bench_instrumented_fairy.txt 2>&1 || true
          # ... run more iterations and merge profraws if any ...
          if compgen -G "${HOME}/pgo-*.profraw" >/dev/null 2>&1 && command -v llvm-profdata >/dev/null 2>&1; then
            llvm-profdata merge -o "${HOME}/merged.profdata" ${HOME}/pgo-*.profraw || echo "llvm-profdata merge failed (continuing)"
          fi
        fi

        make clean || true

        # try profile-build then fallback to plain build
        BUILD_RC=0
        if make -j$(nproc) profile-build ARCH=x86-64-bmi2 COMP=clang 2>&1 | tee build-final.log; then
          BUILD_RC=0
        else
          BUILD_RC=${PIPESTATUS[0]:-1}
        fi

        if [ $BUILD_RC -ne 0 ]; then
          echo "profile-build failed with code $BUILD_RC, attempting plain 'make build'..."
          if make -j$(nproc) build ARCH=x86-64-bmi2 COMP=clang 2>&1 | tee -a build-final.log; then
            BUILD_RC=0
          else
            BUILD_RC=${PIPESTATUS[0]:-1}
          fi
        fi

        if [ $BUILD_RC -ne 0 ]; then
          echo "BUILD FAILED (code $BUILD_RC). Tail of build-final.log:"
          tail -n 400 build-final.log || true
          exit $BUILD_RC
        fi

        found=$(find . -maxdepth 6 -type f -executable -iname 'fairy*' -o -iname 'stockfish*' -o -iname 'fsf*' -print -quit || true)
        if [ -z "$found" ]; then
          found=$(find . -maxdepth 6 -type f -executable -print -quit || true)
        fi
        if [ -z "$found" ]; then
          tail -n 200 build-final.log || true
          echo "ERROR: built binary not found"
          exit 1
        fi
        echo "Found engine binary: $found"
        strip "$found" || true
        mkdir -p "${ROOT}/engines"
        cp "$found" "${ROOT}/engines/fsf" || { echo "Copy failed"; exit 1; }
        chmod +x "${ROOT}/engines/fsf"
        echo "Fairy build complete."

        if make ARCH=x86-64-bmi2 COMP=clang profileclean 2>&1 | tee profileclean_fairy.log; then
          echo "profileclean fairy ok"
        else
          echo "profileclean fairy failed (non-fatal). See profileclean_fairy.log"
          tail -n 200 profileclean_fairy.log || true
        fi

    - name: Setup engines permissions
      run: |
        echo "ðŸ”§ Setting engine permissions..."
        chmod +x engines/fsf || true
        chmod +x engines/sf || true
        chmod +x engines/ShashChess39 || true || true
        echo "ðŸ“‹ Listing engines:"
        ls -la engines/ || true

    - name: Run built-in bench (uses default positions from each engine)
      run: |
        echo "=== Running engine bench (default positions) ==="
        mkdir -p bench_outputs
        if [ -x "./engines/fsf" ]; then
          echo "-> Fairy (engines/fsf) bench (default suite)" | tee bench_outputs/fsf_bench.txt
          ./engines/fsf bench 2>&1 | tee -a bench_outputs/fsf_bench.txt || true
        else
          echo "engines/fsf not found or not executable" | tee bench_outputs/fsf_bench.txt
        fi

        if [ -x "./engines/sf" ]; then
          echo "-> Omega/Stockfish (engines/sf) bench (default suite)" | tee bench_outputs/sf_bench.txt
          ./engines/sf bench 2>&1 | tee -a bench_outputs/sf_bench.txt || true
        else
          echo "engines/sf not found or not executable" | tee bench_outputs/sf_bench.txt
        fi

    - name: Setup token & config
      run: |
        python3 << 'PY'
        import yaml, os, sys
        try:
            cfg_path = 'config.yml'
            try:
                with open(cfg_path, 'r') as f:
                    config = yaml.safe_load(f) or {}
            except FileNotFoundError:
                config = {}
            config['token'] = os.environ.get('LICHESS_TOKEN', '')
            config.setdefault('engine', {})
            config['engine']['dir'] = './engines'
            config['engine']['name'] = 'fsf'
            with open(cfg_path, 'w') as f:
                yaml.dump(config, f, default_flow_style=False)
            print("âœ… Configuration successful")
        except Exception as e:
            print(f"âŒ Error: {e}")
            sys.exit(1)
        PY

    - name: Launch bot
      timeout-minutes: 340
      run: |
        echo "ðŸ¤– Starting bot..."
        python3 user_interface.py matchmaking
